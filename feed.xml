<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://migarstka.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://migarstka.github.io/" rel="alternate" type="text/html" /><updated>2025-08-09T08:33:13+01:00</updated><id>https://migarstka.github.io/feed.xml</id><title type="html">Michael Garstka</title><subtitle>Personal website of Michael Garstka</subtitle><entry><title type="html">Automatic bug discovery with git bisect run</title><link href="https://migarstka.github.io/gitbisect/" rel="alternate" type="text/html" title="Automatic bug discovery with git bisect run" /><published>2021-01-09T00:00:00+00:00</published><updated>2021-01-09T00:00:00+00:00</updated><id>https://migarstka.github.io/git_bisect</id><content type="html" xml:base="https://migarstka.github.io/gitbisect/"><![CDATA[<p>Working on a software project I often realize that I introduced a bug in one of my previous commits.
Especially if the number of candidate commits for the error is large it can be quite tedious to find the problematic commit.
<code class="language-plaintext highlighter-rouge">git bisect</code> is a helpful tool to find the problematic commit using a binary search over the set of candidate commits.
If your commit history looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A -- B -- C -- D -- E -- F -- G -- H -- I -- HEAD
          ^                                    ^
         works                       doesn't work
</code></pre></div></div>
<p>and you know that your code worked at commit <code class="language-plaintext highlighter-rouge">C</code> but not at the <code class="language-plaintext highlighter-rouge">HEAD</code>, Git will checkout the repository at various commits and <em>ask</em> you whether that commit causes the problems. Consequently, you’ll find the bug in <code class="language-plaintext highlighter-rouge">O(log(n))</code> steps where <code class="language-plaintext highlighter-rouge">n</code> is the number of candidate commits that could cause the error. The cool thing about <code class="language-plaintext highlighter-rouge">git bisect</code> is that you can provide a script to tell Git whether a certain commit is still working or not and automate the whole thing.
Moreover, this also works for finding changes that introduce performance problems.</p>

<h2 id="a-bug-in-mergesort">A bug in mergesort</h2>
<p>I have been working on a project that implements mergesort in Julia. The project folder looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject/
|-- merge_sort.jl
|-- unit_test.jl
</code></pre></div></div>
<p>The 
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--1" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-1" for="sidenote__checkbox--1" class="sidenote__button sidenote__button--number-1 ">files</label>
<small id="sidenote-4" class="sidenote__content sidenote__content--number-1">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
The details of the script don’t really matter here. If you want to try and find the bug look closer at the first function <code class="language-plaintext highlighter-rouge">merge_sort!</code>.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span> look like this:</p>

<p><strong>merge_sort.jl</strong></p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="s">"Sort array `a` using merge sort algorithm. Stable. Runtime complexity: O(n log(n)), Space complexity: O(n)."</span>
<span class="k">function</span><span class="nf"> merge_sort!</span><span class="x">(</span><span class="n">arr</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="x">{</span><span class="n">T</span><span class="x">})</span> <span class="k">where</span> <span class="x">{</span><span class="n">T</span> <span class="o">&lt;:</span> <span class="kt">Real</span><span class="x">}</span>
    <span class="n">length</span><span class="x">(</span><span class="n">arr</span><span class="x">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">return</span> <span class="n">arr</span>
    
    <span class="n">helper</span> <span class="o">=</span> <span class="n">similar</span><span class="x">(</span><span class="n">arr</span><span class="x">)</span>
    <span class="n">_merge_sort!</span><span class="x">(</span><span class="n">arr</span><span class="x">,</span> <span class="mi">1</span><span class="x">,</span> <span class="n">length</span><span class="x">(</span><span class="n">arr</span><span class="x">),</span> <span class="n">helper</span><span class="x">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="x">[</span><span class="k">end</span><span class="x">]</span>
    <span class="n">arr</span><span class="x">[</span><span class="k">end</span><span class="x">]</span> <span class="o">=</span> <span class="n">arr</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span>
    <span class="n">arr</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">=</span> <span class="n">tmp</span>
<span class="k">end</span>

<span class="s">"Split array in half and recursively call this function."</span>
<span class="k">function</span><span class="nf"> _merge_sort!</span><span class="x">(</span><span class="n">arr</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="x">{</span><span class="n">T</span><span class="x">},</span> <span class="n">l</span><span class="o">::</span><span class="kt">Int64</span><span class="x">,</span> <span class="n">r</span><span class="o">::</span><span class="kt">Int64</span><span class="x">,</span> <span class="n">helper</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="x">{</span><span class="n">T</span><span class="x">})</span> <span class="k">where</span> <span class="x">{</span><span class="n">T</span> <span class="o">&lt;:</span> <span class="kt">Real</span><span class="x">}</span>
    <span class="c"># single element: already sorted</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">nothing</span>
    <span class="k">end</span>

    <span class="c"># split list and sort individually</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">div</span><span class="x">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span> <span class="o">+</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">_merge_sort!</span><span class="x">(</span><span class="n">arr</span><span class="x">,</span> <span class="n">l</span><span class="x">,</span> <span class="n">m</span><span class="x">,</span> <span class="n">helper</span><span class="x">)</span>
    <span class="n">_merge_sort!</span><span class="x">(</span><span class="n">arr</span><span class="x">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="x">,</span> <span class="n">r</span><span class="x">,</span> <span class="n">helper</span><span class="x">)</span>

    <span class="c"># merge them back together</span>
    <span class="n">merge!</span><span class="x">(</span><span class="n">arr</span><span class="x">,</span> <span class="n">l</span><span class="x">,</span> <span class="n">m</span><span class="x">,</span> <span class="n">r</span><span class="x">,</span> <span class="n">helper</span><span class="x">)</span>

<span class="k">end</span>

<span class="s">"Merge two sorted arrays in sorted fashion."</span>
<span class="k">function</span><span class="nf"> merge!</span><span class="x">(</span><span class="n">arr</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="x">{</span><span class="n">T</span><span class="x">},</span> <span class="n">l</span><span class="o">::</span><span class="kt">Int64</span><span class="x">,</span> <span class="n">m</span><span class="o">::</span><span class="kt">Int64</span><span class="x">,</span> <span class="n">r</span><span class="o">::</span><span class="kt">Int64</span><span class="x">,</span> <span class="n">helper</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="x">{</span><span class="n">T</span><span class="x">})</span> <span class="k">where</span> <span class="x">{</span><span class="n">T</span> <span class="o">&lt;:</span> <span class="kt">Real</span><span class="x">}</span>    
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="o">:</span><span class="n">r</span>
        <span class="n">helper</span><span class="x">[</span><span class="n">k</span><span class="x">]</span> <span class="o">=</span> <span class="n">arr</span><span class="x">[</span><span class="n">k</span><span class="x">]</span>
    <span class="k">end</span>
    <span class="n">helper_l</span> <span class="o">=</span> <span class="n">l</span>
    <span class="n">helper_r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">l</span>

    <span class="c"># compare elements in left and right partition and copy smaller one </span>
    <span class="k">while</span> <span class="n">helper_l</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">helper_r</span> <span class="o">&lt;=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">helper</span><span class="x">[</span><span class="n">helper_l</span><span class="x">]</span> <span class="o">&lt;=</span> <span class="n">helper</span><span class="x">[</span><span class="n">helper_r</span><span class="x">]</span>
            <span class="n">arr</span><span class="x">[</span><span class="n">current</span><span class="x">]</span> <span class="o">=</span> <span class="n">helper</span><span class="x">[</span><span class="n">helper_l</span><span class="x">]</span>
            <span class="n">helper_l</span> <span class="o">+=</span> <span class="mi">1</span>            
        <span class="k">else</span>
            <span class="n">arr</span><span class="x">[</span><span class="n">current</span><span class="x">]</span> <span class="o">=</span> <span class="n">helper</span><span class="x">[</span><span class="n">helper_r</span><span class="x">]</span>
            <span class="n">helper_r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">end</span>
        <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span> 
    <span class="k">end</span>
    
    <span class="c"># transfer any left overs from left partition (greater than all elem in right partition)</span>
    <span class="k">if</span> <span class="n">helper_l</span> <span class="o">&lt;=</span> <span class="n">m</span> 
         <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="n">helper_l</span><span class="o">:</span><span class="n">m</span>
            <span class="n">arr</span><span class="x">[</span><span class="n">current</span><span class="x">]</span> <span class="o">=</span> <span class="n">helper</span><span class="x">[</span><span class="n">k</span><span class="x">]</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Unfortunately, the corresponding unit test <strong>unit_test.jl</strong> for the <code class="language-plaintext highlighter-rouge">merge_sort!</code> function fails:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="c"># import code</span>
<span class="n">include</span><span class="x">(</span><span class="s">"./merge_sort.jl"</span><span class="x">)</span>

<span class="c"># test merge sort code</span>
<span class="k">using</span> <span class="n">Test</span>

<span class="nd">@testset</span> <span class="s">"Test Merge Sort"</span> <span class="k">begin</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="n">randn</span><span class="x">(</span><span class="mi">10000</span><span class="x">)</span> <span class="o">.-</span> <span class="mf">500.</span>
        <span class="n">merge_sort!</span><span class="x">(</span><span class="n">a</span><span class="x">)</span>
        <span class="nd">@test</span> <span class="n">issorted</span><span class="x">(</span><span class="n">a</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Let’s take a look at the previous commits to see if we can figure out which commit might cause the problem.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git log --pretty=oneline
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cb67f4062dfc16f35cbd91a53582c1655705818d (HEAD -&gt; master) Change deepcopy back to similar
1327949703a06918d62198ea34b5a47d36f3a90f Use deepcopy instead of similar
2c84ffd5916809ba1ca922b749ecede7c5f0139c Remove loop annotation
2659d69af012edefc2c444f9ae4556711f7dcb65 [*] Swap first and last element
2783ba6cc0f5cd5db33b5879eb54547743e6fd8c Make if-statement one-liner
86f3851d0ff4838567dbcb265ed07c6b8ef143fd Add function documentation
0d1c8b0fa1aed40ee7fc2f60f2f1d006b849f59e Add unit test
c5b68639402ff014264faf82e7b61beaf446a1ae Initial commit
</code></pre></div></div>
<p>It
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--2" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-2" for="sidenote__checkbox--2" class="sidenote__button sidenote__button--number-2 ">does not seem obvious.</label>
<small id="sidenote-2" class="sidenote__content sidenote__content--number-2">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
Okay, it is fairly obvious. The problematic commit is the one marked <code class="language-plaintext highlighter-rouge">[*]</code>.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span>I only remember that the code in the first commit <code class="language-plaintext highlighter-rouge">c5b6863</code> still worked and in the current commit <code class="language-plaintext highlighter-rouge">HEAD</code> it does not.</p>

<h2 id="manual-git-bisect">Manual git bisect</h2>
<p>We use <code class="language-plaintext highlighter-rouge">git bisect</code> to start the search for the broken commit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git bisect start
</code></pre></div></div>
<p>Next, we give Git the boundary of the search range, i.e. one commit that is bad (the current one):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git bisect bad HEAD
</code></pre></div></div>

<p>and one commit that worked:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git bisect good c5b6863
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bisecting: 3 revisions left to test after this (roughly 2 steps)
[2783ba6cc0f5cd5db33b5879eb54547743e6fd8c] Make if-statement one-liner
</code></pre></div></div>
<p>Git will now go through the range, checkout different commits and ask us if the commit is good or bad. As you can see it first checks out the commit in the middle of the interval <code class="language-plaintext highlighter-rouge">2783ba6</code>. I run <code class="language-plaintext highlighter-rouge">unit_test.jl</code> and the code still works. I tell Git this by using:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject ((no branch, bisect started on master))🚀 $ git bisect good
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bisecting: 1 revision left to test after this (roughly 1 step)
[2c84ffd5916809ba1ca922b749ecede7c5f0139c] Remove loop annotation
</code></pre></div></div>
<p>Next, Git checked out the middle commit <code class="language-plaintext highlighter-rouge">2c84ff</code> in the remaining interval. After running the unit test I realize that the test fails, so I tell Git:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject ((no branch, bisect started on master))🚀 $ git bisect bad
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bisecting: 0 revisions left to test after this (roughly 0 steps)
[2659d69af012edefc2c444f9ae4556711f7dcb65] [*] Swap first and last element
</code></pre></div></div>
<p>It checks out another commit. I try the unit tests and they fail again, so I again use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject ((no branch, bisect started on master))🚀 $ git bisect bad
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2659d69af012edefc2c444f9ae4556711f7dcb65 is the first bad commit
commit 2659d69af012edefc2c444f9ae4556711f7dcb65
Author: Michael 
Date:   Sat Jan 9 14:46:32 2021 +0000

    [*] Swap first and last element

 merge_sort.jl | 3 +++
 1 file changed, 3 insertions(+)
</code></pre></div></div>
<p>The broken commit has been determined. Looking closer at what I did in that commit,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject ((no branch, bisect started on master))🚀 $ git show
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff --git a/merge_sort.jl b/merge_sort.jl
index 0fc13fd..1b41564 100644
--- a/merge_sort.jl
+++ b/merge_sort.jl
@@ -4,6 +4,9 @@ function merge_sort!(a::AbstractArray{T}) where {T &lt;: Real}

     helper = similar(a)
     _merge_sort!(a, 1, length(a), helper)
+    tmp = a[end]
+    a[end] = a[1]
+    a[1] = tmp
 end
</code></pre></div></div>

<p>I can see that I accidentally swapped the first and last element of the array after sorting it. If at any point during the search process I had misclassified a commit, I could have stopped the search with <code class="language-plaintext highlighter-rouge">git bisect reset</code>.</p>

<h2 id="automatic-git-bisect">Automatic git bisect</h2>

<p>We can make our lifes easier by providing a script that tests each commit during the bisection process and tells Git if the commit is good or bad.
The syntax for this is <code class="language-plaintext highlighter-rouge">git bisect run my_script arguments</code>.
In this example we can simply use our unit test as the script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git bisect start
MergeSortProject (master)🚀 $ git bisect bad HEAD
MergeSortProject (master)🚀 $ git bisect good c5b6863
MergeSortProject (master)🚀 $ git bisect run julia unit_test.jl
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">running julia unit_test.jl
Test Summary: | Pass  Total
Merge Sort    |    3      3
Bisecting: 1 revision left to <span class="nb">test </span>after this <span class="o">(</span>roughly 1 step<span class="o">)</span>
<span class="o">[</span>2c84ffd5916809ba1ca922b749ecede7c5f0139c] Remove loop annotation
running julia unit_test.jl
Test Merge Sort: Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11
  Expression: issorted<span class="o">(</span>a<span class="o">)</span>
Stacktrace:
 <span class="o">[</span>1] macro expansion at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11 <span class="o">[</span>inlined]
 <span class="o">[</span>2] macro expansion at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 <span class="o">[</span>inlined]
 <span class="o">[</span>3] top-level scope at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:8
Test Merge Sort: Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11
  Expression: issorted<span class="o">(</span>a<span class="o">)</span>
Stacktrace:
 <span class="o">[</span>1] macro expansion at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11 <span class="o">[</span>inlined]
 <span class="o">[</span>2] macro expansion at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 <span class="o">[</span>inlined]
 <span class="o">[</span>3] top-level scope at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:8
Test Merge Sort: Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11
  Expression: issorted<span class="o">(</span>a<span class="o">)</span>
Stacktrace:
 <span class="o">[</span>1] macro expansion at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11 <span class="o">[</span>inlined]
 <span class="o">[</span>2] macro expansion at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 <span class="o">[</span>inlined]
 <span class="o">[</span>3] top-level scope at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:8
Test Summary:   | Fail  Total
Test Merge Sort |    3      3
ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.
<span class="k">in </span>expression starting at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:7
Bisecting: 0 revisions left to <span class="nb">test </span>after this <span class="o">(</span>roughly 0 steps<span class="o">)</span>
<span class="o">[</span>2659d69af012edefc2c444f9ae4556711f7dcb65] <span class="o">[</span><span class="k">*</span><span class="o">]</span> Swap first and last element
running julia unit_test.jl
Merge Sort: Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11
  Expression: issorted<span class="o">(</span>a<span class="o">)</span>
Stacktrace:
 <span class="o">[</span>1] macro expansion at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11 <span class="o">[</span>inlined]
 <span class="o">[</span>2] macro expansion at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 <span class="o">[</span>inlined]
 <span class="o">[</span>3] top-level scope at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:8
Merge Sort: Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11
  Expression: issorted<span class="o">(</span>a<span class="o">)</span>
Stacktrace:
 <span class="o">[</span>1] macro expansion at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11 <span class="o">[</span>inlined]
 <span class="o">[</span>2] macro expansion at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 <span class="o">[</span>inlined]
 <span class="o">[</span>3] top-level scope at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:8
Merge Sort: Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11
  Expression: issorted<span class="o">(</span>a<span class="o">)</span>
Stacktrace:
 <span class="o">[</span>1] macro expansion at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:11 <span class="o">[</span>inlined]
 <span class="o">[</span>2] macro expansion at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 <span class="o">[</span>inlined]
 <span class="o">[</span>3] top-level scope at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:8
Test Summary: | Fail  Total
Merge Sort    |    3      3
ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.
<span class="k">in </span>expression starting at /Users/Micha/Dropbox/Research/GitBisectExp/unit_test.jl:7
2659d69af012edefc2c444f9ae4556711f7dcb65 is the first bad commit
commit 2659d69af012edefc2c444f9ae4556711f7dcb65
Author: Michael 
Date:   Sat Jan 9 14:46:32 2021 +0000

    <span class="o">[</span><span class="k">*</span><span class="o">]</span> Swap first and last element

 merge_sort.jl | 3 +++
 1 file changed, 3 insertions<span class="o">(</span>+<span class="o">)</span>
bisect run success</code></pre></figure>

<p>The output shows that the unit test passes on the first suggested commit and then fails twice, which correctly identifies the broken commit <code class="language-plaintext highlighter-rouge">[*] Swap first and last element</code> as before.</p>

<p>In this example the unit test file <code class="language-plaintext highlighter-rouge">unit_test.jl</code> is also tracked in the repository. Only use a tracked script if you are sure that the script itself does not introduce the problem or was changed severely by one of the commits.</p>

<h2 id="finding-performance-digressions">Finding performance digressions</h2>
<p>Above workflow is not only useful to find bugs.
It can also be used to find commits that reduce the performance of our code.</p>

<p>After finding the bug in the previous section, I committed a fix (<code class="language-plaintext highlighter-rouge">a53c36</code>). I also benchmarked my code and found that it takes <code class="language-plaintext highlighter-rouge">108.5μs</code> to sort an array of length <code class="language-plaintext highlighter-rouge">5000</code>. After working a bit longer on the code I realize that the code has noticeably slowed down. Sorting the same array now takes <code class="language-plaintext highlighter-rouge">122.2ms</code>. All the unit tests still pass, so one of my changes must cause the slowdown.
Let’s look again at the commit log:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git log --pretty=oneline
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4fdadbc9304bea5e9db90267fbc36ce12b7fffca (HEAD -&gt; master) Add comment on function call
4c47b70d0cc90630460bc5f744338767972d475f [**] Don't reuse helper
be3c1deb31b1f1595338f09f495dae72937abf7e Rename `merge!` to `_merge!`
1d96d60a3927f7eaaca13a282137bca87b785818 Make if-stament oneliner
a53c361b69efc45780ac90cacf8d51ab00a0f0fc Fix bug found using git bisect
cb67f4062dfc16f35cbd91a53582c1655705818d Change deepcopy back to similar
1327949703a06918d62198ea34b5a47d36f3a90f Use deepcopy instead of similar
2c84ffd5916809ba1ca922b749ecede7c5f0139c Remove loop annotation
2659d69af012edefc2c444f9ae4556711f7dcb65 [*] Swap first and last element
2783ba6cc0f5cd5db33b5879eb54547743e6fd8c Make if-statement one-liner
86f3851d0ff4838567dbcb265ed07c6b8ef143fd Add function documentation
0d1c8b0fa1aed40ee7fc2f60f2f1d006b849f59e Add unit test
c5b68639402ff014264faf82e7b61beaf446a1ae Initial commit
</code></pre></div></div>

<p>I can use <code class="language-plaintext highlighter-rouge">git bisect</code> to find the commit that is causing the performance issues by writing a script that benchmarks the sorting algorithm and compares it to a target time plus some tolerance. If the test passes the commit is classified as good and as bad otherwise. We can use the following script:</p>

<p><strong>time_code.jl</strong></p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">using</span> <span class="n">BenchmarkTools</span><span class="x">,</span> <span class="n">Test</span><span class="x">,</span> <span class="n">Random</span>
<span class="n">include</span><span class="x">(</span><span class="s">"./merge_sort.jl"</span><span class="x">)</span>

<span class="c"># run benchmark</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">Random</span><span class="o">.</span><span class="kt">MersenneTwister</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="n">randn</span><span class="x">(</span><span class="n">rng</span><span class="x">,</span> <span class="mi">5000</span><span class="x">)</span> <span class="o">.-</span> <span class="mf">500.</span>
<span class="n">min_time</span> <span class="o">=</span> <span class="nd">@belapsed</span> <span class="n">merge_sort!</span><span class="x">(</span><span class="o">$</span><span class="n">a</span><span class="x">)</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">target_time</span> <span class="o">=</span> <span class="n">parse</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="nb">ARGS</span><span class="x">[</span><span class="mi">1</span><span class="x">])</span>

<span class="n">println</span><span class="x">(</span><span class="s">"Benchmark time: </span><span class="si">$(min_time) </span><span class="s">vs. target time (+tol): </span><span class="si">$</span><span class="s">(tol * target_time)"</span><span class="x">)</span>
<span class="nd">@test</span> <span class="n">min_time</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">target_time</span></code></pre></figure>

<p>Next, we run the bisection and pass our target time (<code class="language-plaintext highlighter-rouge">108.5μs</code>) to the script.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git bisect start
MergeSortProject (master)🚀 $ git bisect bad HEAD
MergeSortProject (master)🚀 $ git bisect good a53c361
MergeSortProject (master)🚀 $ git bisect run julia time_code.jl 0.000108514
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject (master)🚀 $ git bisect run julia time_code.jl  0.000108514
running julia time_code.jl 0.000108514
Benchmark time: 0.000105667 vs. target time (+tol): 0.00011936540000000001
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[4c47b70d0cc90630460bc5f744338767972d475f] [**] Don't reuse helper
running julia time_code.jl 0.000108514
Benchmark time: 0.1221385 vs. target time (+tol): 0.00011936540000000001
Test Failed at /Users/Micha/Dropbox/Research/GitBisectExp/time_code.jl:12
  Expression: min_time &lt; tol * target_time
   Evaluated: 0.1221385 &lt; 0.00011936540000000001
ERROR: LoadError: There was an error during testing
in expression starting at /Users/Micha/Dropbox/Research/GitBisectExp/time_code.jl:12
4c47b70d0cc90630460bc5f744338767972d475f is the first bad commit
commit 4c47b70d0cc90630460bc5f744338767972d475f
Author: Michael Garstka &lt;michael@garstka.org&gt;
Date:   Tue Jan 12 22:40:24 2021 +0000

    [**] Don't reuse helper

 merge_sort.jl | 19 +++++++++----------
 1 file changed, 9 insertions(+), 10 deletions(-)
bisect run success
</code></pre></div></div>
<p>We can take a closer look at the identified commit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MergeSortProject ((no branch, bisect started on master))🚀 $ git show 4c47b70d0
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff --git a/merge_sort.jl b/merge_sort.jl
index e6f4439..4ae0234 100644
--- a/merge_sort.jl
+++ b/merge_sort.jl
@@ -2,13 +2,13 @@
 function merge_sort!(arr::AbstractArray{T}) where {T &lt;: Real}
     length(arr) &lt;= 1 &amp;&amp; return arr

-    helper = similar(arr)
-    _merge_sort!(arr, 1, length(arr), helper)
+
+    _merge_sort!(arr, 1, length(arr))

 end

 "Split array and half and recursively call this function."
-function _merge_sort!(arr::AbstractArray{T}, l::Int64, r::Int64, helper::AbstractArray{T}) where {T &lt;: Real}
+function _merge_sort!(arr::AbstractArray{T}, l::Int64, r::Int64) where {T &lt;: Real}
     # single element: already sorted
     r - l &lt;= 0 &amp;&amp; return nothing

@@ -16,19 +16,18 @@ function _merge_sort!(arr::AbstractArray{T}, l::Int64, r::Int64, helper::Abstrac
     # split list and sort individually
     m = div(r - l + 1, 2) + l - 1

-    _merge_sort!(arr, l, m, helper)
-    _merge_sort!(arr, m + 1, r, helper)
+    _merge_sort!(arr, l, m)
+    _merge_sort!(arr, m + 1, r)

     # merge them back together
-    _merge!(arr, l, m, r, helper)
+    _merge!(arr, l, m, r)

 end

 "Merge two sorted arrays in sorted fashion."
-function _merge!(arr::AbstractArray{T}, l::Int64, m::Int64, r::Int64, helper::AbstractArray{T}) where {T &lt;: Real}
-    for k = l:r
-        helper[k] = arr[k]
-    end
+function _merge!(arr::AbstractArray{T}, l::Int64, m::Int64, r::Int64) where {T &lt;: Real}
+    helper = deepcopy(arr)
+
     helper_l = l
     helper_r = m + 1
     current = l
</code></pre></div></div>
<p>And indeed, that commit introduced repeated allocation of the <code class="language-plaintext highlighter-rouge">helper</code> array in <code class="language-plaintext highlighter-rouge">_merge!</code> which causes the slowdown of the algorithm.</p>]]></content><author><name></name></author><category term="git" /><category term="julia" /><summary type="html"><![CDATA[Working on a software project I often realize that I introduced a bug in one of my previous commits. Especially if the number of candidate commits for the error is large it can be quite tedious to find the problematic commit. git bisect is a helpful tool to find the problematic commit using a binary search over the set of candidate commits. If your commit history looks like this:]]></summary></entry><entry><title type="html">Running Julia jobs on an HPC cluster</title><link href="https://migarstka.github.io/juliahpc/" rel="alternate" type="text/html" title="Running Julia jobs on an HPC cluster" /><published>2020-12-17T00:00:00+00:00</published><updated>2020-12-17T00:00:00+00:00</updated><id>https://migarstka.github.io/julia_hpc</id><content type="html" xml:base="https://migarstka.github.io/juliahpc/"><![CDATA[<p>One of the bigger productivity improvements for me in terms of tweaking and benchmarking algorithms was the ability to run Julia code on my university’s HPC nodes. This allowed me to test different versions of my code in parallel while still being able to do other work on my local machine. This is a quick tutorial on how to 
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--4" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-4" for="sidenote__checkbox--4" class="sidenote__button sidenote__button--number-4 ">setup Julia </label>
<small id="sidenote-4" class="sidenote__content sidenote__content--number-4">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
This tutorial is intended for a Julia project, but most of the content applies if you want to run jobs in C++/R/Python/etc.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span> 
on a computing cluster and use SLURM to manage compute jobs.</p>

<p>I am writing this based on my experience with the <a href="https://www.arc.ox.ac.uk/arc-systems">University of Oxford HPC  cluster</a> (Arcus-HTC) which runs CentOS Linux 7 and uses <a href="slurm.schedmd.com/">SLURM</a> for job scheduling. This means that based on your university / company setup your experience may differ. In particular the ARC login nodes are connected to the internet which makes installing Julia packages a lot easier.</p>

<h2 id="login-and-installing-julia">Login and installing Julia</h2>
<p>Once you have an account for Oxford ARC, connect to the University VPN and login via ssh:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ssh <span class="nt">-X</span> USERNAME@oscgate.arc.ox.ac.uk</code></pre></figure>

<p>You’ll likely connect to one of the cluster’s login nodes. Oxford ARC has different partitions you can choose for your jobs:</p>

<ul>
  <li>Arcus-B for multi-node parallel computation</li>
  <li>Arcus-HTC for high-throughput lower core count jobs.</li>
</ul>

<p>I want to use the HTC nodes, so I will again connect to them via ssh:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ssh <span class="nt">-X</span> arcus-htc</code></pre></figure>

<p>On the login node, two important folders were created for each user:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$HOME/</code> - points to the home directory associated with your user account</li>
  <li><code class="language-plaintext highlighter-rouge">$DATA/</code> - a folder to store larger files</li>
</ul>

<p>To 
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--3" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-3" for="sidenote__checkbox--3" class="sidenote__button sidenote__button--number-3 ">install Julia </label>
<small id="sidenote-3" class="sidenote__content sidenote__content--number-3">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
Some version of Julia/Python/R/Matlab might already be available on ARC. Check with <code class="language-plaintext highlighter-rouge">module avail</code>.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span> 
we simply download the <a href="https://julialang.org/downloads/">Julia binaries</a> to our <code class="language-plaintext highlighter-rouge">$DATA/</code> folder and unzip them:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="nv">$DATA</span>
wget https://julialang-s3.julialang.org/bin/linux/x64/1.5/julia-1.5.3-linux-x86_64.tar.gz
<span class="nb">tar</span> <span class="nt">-xzf</span> julia-1.5.3-linux-x86_64.tar.gz</code></pre></figure>

<p>To run Julia on the login node we can type:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./julia-1.5.3-linux-x86_64/bin/julia</code></pre></figure>

<p>(You should generally not run any significant computations on the login nodes, but it is a good way to check that everything works. Also it is a good idea to create a symlink or alias to <code class="language-plaintext highlighter-rouge">/julia-1.5.3-linux-x86_64/bin/julia</code>. )</p>

<h2 id="installing-julia-packages">Installing Julia packages</h2>
<p>You’ll find your Julia home folder at <code class="language-plaintext highlighter-rouge">$HOME/.julia/</code>. Since the ARC nodes are connected to the internet you can simply download any packages using the normal workflow. I am assuming here that we want to setup some scripts in the project folder <code class="language-plaintext highlighter-rouge">$DATA/myproject/</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Run Julia
2. Create a new project environment `activate .`
3. Install packages: Type `]` and `pkg&gt; add Statistics`
</code></pre></div></div>

<h2 id="uploading-your-code">Uploading your code</h2>
<p>This is a matter of taste but I prefer to be able to modify any of my code both locally and remotely. I therefore initialise <code class="language-plaintext highlighter-rouge">/myproject</code> as a
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--1" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-1" for="sidenote__checkbox--1" class="sidenote__button sidenote__button--number-1 ">Git repository</label>.
<small id="sidenote-1" class="sidenote__content sidenote__content--number-1">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
A quick overview to get started with Git can be found <a href="https://rogerdudler.github.io/git-guide/">here</a>. 
<span class="sidenote__content-parenthesis">)</span>
</small>
</span>
I can then edit a local copy and <code class="language-plaintext highlighter-rouge">git push</code> any of the local changes or vice versa. The project dependencies for this project are tracked by Julia in the  <code class="language-plaintext highlighter-rouge">Project.toml</code> and <code class="language-plaintext highlighter-rouge">Manifest.toml</code> files. Changes in both files are also tracked via Git to make sure the same dependencies are used locally and remotely.</p>

<p>This setup allows me to test or debug any changes to my code locally and be certain that it will run the same way on the remote node. Debugging the code on the remote node is more time consuming because your compute jobs do not necessarily execute immediately. For example it might take several minutes until you receive the error message that you misspelled a function name.</p>

<p>Sometimes I want to upload files from my machine without tracking them via git, e.g. large dataset files like <code class="language-plaintext highlighter-rouge">dataset.csv</code>. To transfer files I use <code class="language-plaintext highlighter-rouge">scp</code> 
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--5" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-5" for="sidenote__checkbox--5" class="sidenote__button sidenote__button--number-5 ">(secure copy protocol)</label>.
<small id="sidenote-5" class="sidenote__content sidenote__content--number-5">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
Syntax: scp [OPTION] [user@SRC_HOST:]file1 [user@DEST_HOST:]file2
<span class="sidenote__content-parenthesis">)</span>
</small>
</span>
To upload <code class="language-plaintext highlighter-rouge">dataset.csv</code> I simply type:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">scp dataset.csv USERNAME@oscgate.arc.ox.ac.uk:/home/USERNAME/.</code></pre></figure>

<p>To transfer a result file <code class="language-plaintext highlighter-rouge">results.csv</code> back to the current folder on my local machine I can use the same command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">scp USERNAME@oscgate.arc.ox.ac.uk:/home/USERNAME/results.csv .</code></pre></figure>

<h2 id="scheduling-jobs">Scheduling jobs</h2>
<p>Oxford ARC uses the <a href="slurm.schedmd.com/">SLURM</a> workload manager to request and manage compute jobs. Assuming we are still in the folder <code class="language-plaintext highlighter-rouge">$DATA/myproject</code> the basic workflow to create a new job is:</p>

<ul>
  <li>write a Julia script <code class="language-plaintext highlighter-rouge">myscript.jl</code> to run your code</li>
  <li>manage all Julia project dependencies using the environment files <code class="language-plaintext highlighter-rouge">Project.toml</code> and <code class="language-plaintext highlighter-rouge">Manifest.toml</code></li>
  <li>write a job submission script <code class="language-plaintext highlighter-rouge">run_job.sh</code> that requests compute resources and tells the compute nodes what to do</li>
</ul>

<p>Let’s assume we want to run the following script <code class="language-plaintext highlighter-rouge">myscript.jl</code> to (inefficiently) compute and print the 20-th Fibonacci number:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">function</span><span class="nf"> fibonacci</span><span class="x">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int64</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="x">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">println</span><span class="x">(</span><span class="s">"The 20-th fibonacci number is </span><span class="si">$</span><span class="s">(fibonacci(20))."</span><span class="x">)</span></code></pre></figure>

<p>To run this script on one of the compute nodes we define a submission script <code class="language-plaintext highlighter-rouge">run_job.sh</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c">#SBATCH --time=0:05:00</span>
<span class="c">#SBATCH --job-name="Fibonacci_calculation"</span>
<span class="c">#SBATCH --nodes=1</span>
<span class="c">#SBATCH --ntasks-per-node=1</span>
<span class="c">#SBATCH --partition=htc</span>
<span class="c">#SBATCH --output="Fibonacci.out"</span>
<span class="c">#SBATCH --error="Fibonacci.err.out"</span>
<span class="c">#SBATCH --mail-type=ALL</span>
<span class="c">#SBATCH --mail-user=YOUR_EMAIL_ADDRESS</span>

<span class="nv">$DATA</span>/julia-1.5.3-linux-x86_64/bin/julia <span class="nt">--project</span> <span class="nt">-e</span> <span class="s1">'import Pkg; Pkg.instantiate();
include("myscript.jl")'</span></code></pre></figure>

<p>Lines starting with <code class="language-plaintext highlighter-rouge">#SBATCH</code> are SLURM commands. We request 5min of computation time on one CPU. We further want to run it on the ARC-HTC partition and get status updates about our job sent to our email.</p>

<p>The last line in the script calls Julia, instantiates the 
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--7" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-7" for="sidenote__checkbox--7" class="sidenote__button sidenote__button--number-7 ">project environment</label>,
<small id="sidenote-7" class="sidenote__content sidenote__content--number-7">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
Suggested reading: <a href="https://julialang.github.io/Pkg.jl/v1/environments/">Working with environments</a>.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span>i.e. installs any package dependencies defined in <code class="language-plaintext highlighter-rouge">Project.toml</code>, and runs our script.</p>

<p>We then submit the job using the shell with</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sbatch run_job.sh</code></pre></figure>

<p>Depending on the available resources the job is then queued and waiting for execution. You can look up the current job status with</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">squeue <span class="nt">-u</span> USERNAME</code></pre></figure>

<p>To cancel the job use either of the two:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">scancel <span class="nt">-j</span> <span class="o">[</span>JOBNUMBER]
scancel <span class="nt">-u</span> <span class="o">[</span>USERNAME]</code></pre></figure>

<h3 id="job-arrays">Job arrays</h3>
<p>Sometimes we want to run the same job multiple times with only minor modifications, e.g. running our algorithm with one of the hyperparameters changed. For this case SLURM <a href="https://slurm.schedmd.com/job_array.html">job arrays</a> are quite useful. They execute the submission script multiple times and allow you to run different versions of the same script.
The ability to run time-consuming jobs in parallel can be a big time saver.
Let’s assume that we want to calculate the Fibonacci number for <code class="language-plaintext highlighter-rouge">n = 20, 30, 40</code> in separate jobs.</p>

<p>To achieve this we add one line with an array command to our submission script <code class="language-plaintext highlighter-rouge">run_job.sh</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c">#SBATCH --time=0:05:00</span>
<span class="c">#SBATCH --job-name="Fibonacci_calculation"</span>
<span class="c">#SBATCH --nodes=1</span>
<span class="c">#SBATCH --ntasks-per-node=1</span>
<span class="c">#SBATCH --partition=htc</span>
<span class="c">#SBATCH --output="Fibonacci_%a.out"</span>
<span class="c">#SBATCH --error="Fibonacci_%a.err.out"</span>
<span class="c">#SBATCH --mail-type=ALL</span>
<span class="c">#SBATCH --mail-user=YOUR_EMAIL_ADDRESS</span>
<span class="c">#SBATCH --array=1-3</span>

<span class="nv">$DATA</span>/julia-1.5.3-linux-x86_64/bin/julia <span class="nt">--project</span> <span class="nt">-e</span> <span class="s1">'import Pkg; Pkg.instantiate();
include("myscript.jl")'</span></code></pre></figure>

<p>The job will now run three times. The array id is given by the environment variable<code class="language-plaintext highlighter-rouge">SLURM_ARRAY_TASK_ID</code> which we can use inside our Julia script to select <code class="language-plaintext highlighter-rouge">n</code>:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="c"># get the environment variable</span>
<span class="n">task_id</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">parse</span><span class="x">(</span><span class="kt">Int</span><span class="x">,</span> <span class="nb">ENV</span><span class="x">[</span><span class="s">"SLURM_ARRAY_TASK_ID"</span><span class="x">])</span>
<span class="n">n_arr</span> <span class="o">=</span> <span class="x">[</span><span class="mi">20</span><span class="x">;</span> <span class="mi">30</span><span class="x">;</span> <span class="mi">40</span><span class="x">]</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">n_arr</span><span class="x">[</span><span class="n">task_id</span><span class="x">]</span>

<span class="k">function</span><span class="nf"> fibonacci</span><span class="x">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int64</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="x">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">println</span><span class="x">(</span><span class="s">"The </span><span class="si">$(n)-</span><span class="s">th fibonacci number is </span><span class="si">$</span><span class="s">(fibonacci(n))."</span><span class="x">)</span></code></pre></figure>

<h3 id="multithreading">Multithreading</h3>
<p>To use multithreading in our Julia script we have to request multiple cores on a computing node. The following script <code class="language-plaintext highlighter-rouge">my_multithreaded_script.jl</code> is used to compute the Fibonacci number for different <code class="language-plaintext highlighter-rouge">n</code> on
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--6" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-6" for="sidenote__checkbox--6" class="sidenote__button sidenote__button--number-6 ">parallel threads
</label>:
<small id="sidenote-6" class="sidenote__content sidenote__content--number-6">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
This is not the best example for multithreading, because computing the Fibonacci number for the highest <code class="language-plaintext highlighter-rouge">n</code> computes the Fibonacci number for all lower <code class="language-plaintext highlighter-rouge">n</code> in the process.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span></p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="c"># check number of threads</span>
<span class="n">println</span><span class="x">(</span><span class="s">"Number of threads: </span><span class="si">$</span><span class="s">(Threads.nthreads())"</span><span class="x">)</span>

<span class="n">n_arr</span> <span class="o">=</span> <span class="x">[</span><span class="mi">5</span><span class="x">;</span> <span class="mi">10</span><span class="x">;</span> <span class="mi">15</span><span class="x">;</span> <span class="mi">20</span><span class="x">;</span> <span class="mi">25</span><span class="x">;</span> <span class="mi">30</span><span class="x">;</span> <span class="mi">35</span><span class="x">;</span> <span class="mi">40</span><span class="x">]</span>

<span class="k">function</span><span class="nf"> fibonacci</span><span class="x">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int64</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="x">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c"># use multiple threads to compute the fibonacci number for each n in n_arr</span>
<span class="n">fib</span> <span class="o">=</span> <span class="n">zeros</span><span class="x">(</span><span class="n">length</span><span class="x">(</span><span class="n">n_arr</span><span class="x">))</span>
<span class="n">Threads</span><span class="o">.</span><span class="nd">@threads</span> <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">length</span><span class="x">(</span><span class="n">n_arr</span><span class="x">)</span>
    <span class="n">fib</span><span class="x">[</span><span class="n">k</span><span class="x">]</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="x">(</span><span class="n">n_arr</span><span class="x">[</span><span class="n">k</span><span class="x">])</span>
<span class="k">end</span></code></pre></figure>

<p>To run this script we use the following modified SLURM submission script:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c">#SBATCH --time=0:05:00</span>
<span class="c">#SBATCH --job-name="Fibonacci_multithreaded_calculation"</span>
<span class="c">#SBATCH --nodes=1</span>
<span class="c">#SBATCH --ntasks-per-node=8</span>
<span class="c">#SBATCH --partition=htc</span>
<span class="c">#SBATCH --output="Fibonacci.out"</span>
<span class="c">#SBATCH --error="Fibonacci.err.out"</span>
<span class="c">#SBATCH --mail-type=ALL</span>
<span class="c">#SBATCH --mail-user=YOUR_EMAIL_ADDRESS</span>

<span class="nb">export </span><span class="nv">JULIA_NUM_THREADS</span><span class="o">=</span>8
<span class="nv">$DATA</span>/julia-1.5.3-linux-x86_64/bin/julia <span class="nt">--project</span> <span class="nt">-e</span> <span class="s1">'import Pkg; Pkg.instantiate();
include("my_multithreaded_script.jl")'</span></code></pre></figure>

<p>The only changes are that we now request 8 cores on one node and export the environment variable <code class="language-plaintext highlighter-rouge">JULIA_NUM_THREADS</code> to start Julia with 8 threads.</p>

<h3 id="ensuring-consistent-results">Ensuring consistent results</h3>
<p>Let’s assume that you want to benchmark your algorithm, e.g. measure its execution time. In order to generate consistent results from multiple runs, you have to make sure that the Julia script is executed on the same hardware every time. If no hardware is specified SLURM will just run the job on the next available node. If the node has eight CPUs and your job runs on four of them, then the performance of your job will depend on what other jobs run on the remaining four CPUs.</p>

<p>To ensure
<span class="sidenote">
<input aria-label="Show sidenote" type="checkbox" id="sidenote__checkbox--2" class="sidenote__checkbox" />
<label tabindex="0" title="" aria-describedby="sidenote-2" for="sidenote__checkbox--2" class="sidenote__button sidenote__button--number-2 ">consistent results</label>
<small id="sidenote-1" class="sidenote__content sidenote__content--number-2">
<span class="sidenote__content-parenthesis "> (sidenote: </span>
There will still be some variance in your time measurement. If more accuracy is required, I suggest running the script a number of times (using a job array) and averaging the result.
<span class="sidenote__content-parenthesis">)</span>
</small>
</span> you will have to specify the node hardware and request all the CPUs on a node. Information about the different nodes within the Oxford HTC partition can be found <a href="https://www.arc.ox.ac.uk/arcus-htc-reference-guide">here</a>.</p>

<p>Let’s assume that we want to run our job on a SandyBridge E5-2650 (2GHz) node. We can request exclusive access to a whole node by using SLURM constraints. Just add the following lines to the <code class="language-plaintext highlighter-rouge">run_job.sh</code> submission script:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#SBATCH --constraint='cpu_sku:E5-2650'</span>
<span class="c">#SBATCH --exclusive</span></code></pre></figure>]]></content><author><name></name></author><category term="julia" /><category term="HPC" /><summary type="html"><![CDATA[One of the bigger productivity improvements for me in terms of tweaking and benchmarking algorithms was the ability to run Julia code on my university’s HPC nodes. This allowed me to test different versions of my code in parallel while still being able to do other work on my local machine. This is a quick tutorial on how to setup Julia (sidenote: This tutorial is intended for a Julia project, but most of the content applies if you want to run jobs in C++/R/Python/etc. ) on a computing cluster and use SLURM to manage compute jobs.]]></summary></entry></feed>